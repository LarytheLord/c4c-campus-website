#!/usr/bin/env node
/**
 * Schema-Types Synchronization Check
 *
 * This script verifies that TypeScript types match the database schema.
 * It can be run as part of CI to ensure type definitions stay in sync.
 *
 * Usage:
 *   npm run db:types:check           # Basic type structure validation
 *   npm run db:types:check:full      # Includes field name scanning (local convenience)
 *
 * The script will:
 * 1. Verify generated.ts exists and has expected structure
 * 2. Parse schema.sql to extract table definitions
 * 3. Compare against TypeScript type definitions
 * 4. Report any mismatches
 * 5. Optionally run field name scanner for codebase-wide validation
 *
 * Options:
 *   --with-field-scan  Also scan codebase for field name mismatches (local convenience)
 *
 * CI Note:
 *   In CI, field-name and case checks run as separate steps for clearer reporting.
 *   The --with-field-scan option is primarily for local development convenience
 *   when you want to run all checks with a single command.
 *
 * @see docs/DATABASE.md for full documentation
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { spawn } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SCHEMA_PATH = path.join(__dirname, '..', 'schema.sql');
const TYPES_DIR = path.join(__dirname, '..', 'src', 'types');
const GENERATED_PATH = path.join(TYPES_DIR, 'generated.ts');

// Parse command line arguments
const args = process.argv.slice(2);
const WITH_FIELD_SCAN = args.includes('--with-field-scan');

// Core LMS tables that must be kept in sync
const LMS_TABLES = [
  'courses',
  'modules',
  'lessons',
  'cohorts',
  'cohort_enrollments',
  'cohort_schedules',
  'lesson_progress',
  'quizzes',
  'quiz_questions',
  'quiz_attempts',
  'assignments',
  'assignment_submissions',
  'assignment_rubrics',
  'enrollments',
];

// SQL type to TypeScript type mapping
const TYPE_MAP = {
  'uuid': 'string',
  'text': 'string',
  'varchar': 'string',
  'character varying': 'string',
  'integer': 'number',
  'int': 'number',
  'bigint': 'number',
  'smallint': 'number',
  'real': 'number',
  'double precision': 'number',
  'numeric': 'number',
  'decimal': 'number',
  'boolean': 'boolean',
  'bool': 'boolean',
  'timestamp': 'string',
  'timestamptz': 'string',
  'timestamp with time zone': 'string',
  'timestamp without time zone': 'string',
  'date': 'string',
  'time': 'string',
  'jsonb': 'Record<string, unknown> | unknown[]',
  'json': 'Record<string, unknown> | unknown[]',
};

function parseSchemaSQL(content) {
  const tables = {};

  // Match CREATE TABLE statements
  const tableRegex = /CREATE TABLE\s+(?:IF NOT EXISTS\s+)?(?:public\.)?(\w+)\s*\(([\s\S]*?)\);/gi;

  let match;
  while ((match = tableRegex.exec(content)) !== null) {
    const tableName = match[1];
    const columnsBlock = match[2];

    if (!LMS_TABLES.includes(tableName)) continue;

    const columns = {};

    // Parse column definitions
    const lines = columnsBlock.split('\n');
    for (const line of lines) {
      const trimmed = line.trim();

      // Skip constraints, comments, etc.
      if (!trimmed ||
          trimmed.startsWith('--') ||
          trimmed.startsWith('CONSTRAINT') ||
          trimmed.startsWith('PRIMARY KEY') ||
          trimmed.startsWith('FOREIGN KEY') ||
          trimmed.startsWith('UNIQUE') ||
          trimmed.startsWith('CHECK')) {
        continue;
      }

      // Parse column: name type [constraints]
      const colMatch = trimmed.match(/^(\w+)\s+([A-Za-z_]+(?:\s*\([^)]+\))?)/i);
      if (colMatch) {
        const colName = colMatch[1];
        let colType = colMatch[2].toLowerCase().trim();

        // Normalize type
        colType = colType.replace(/\(\d+\)/g, ''); // Remove size specifiers

        const isNullable = !trimmed.toUpperCase().includes('NOT NULL');
        const hasDefault = trimmed.toUpperCase().includes('DEFAULT');

        columns[colName] = {
          sqlType: colType,
          tsType: TYPE_MAP[colType] || 'unknown',
          nullable: isNullable,
          hasDefault,
        };
      }
    }

    tables[tableName] = columns;
  }

  return tables;
}

function checkGeneratedTypes() {
  const issues = [];

  if (!fs.existsSync(GENERATED_PATH)) {
    issues.push({
      type: 'error',
      message: 'generated.ts not found - run "npm run db:types" to create it',
    });
    return { exists: false, issues };
  }

  const content = fs.readFileSync(GENERATED_PATH, 'utf-8');

  // Check for expected structure
  if (!content.includes('export type Database = {')) {
    issues.push({
      type: 'error',
      message: 'generated.ts missing Database type - regenerate with "npm run db:types"',
    });
  }

  // Check for auto-generated header comment
  if (!content.includes('DO NOT EDIT THIS FILE MANUALLY')) {
    issues.push({
      type: 'error',
      message: 'generated.ts missing "DO NOT EDIT" header - file may have been manually edited',
    });
  }

  // Check for expected LMS table types
  const expectedTables = ['quizzes', 'quiz_questions', 'quiz_attempts', 'assignments', 'assignment_submissions'];
  for (const table of expectedTables) {
    if (!content.includes(`${table}: {`)) {
      issues.push({
        type: 'warning',
        message: `generated.ts missing "${table}" table definition`,
      });
    }
  }

  // Check for helper type exports
  const expectedHelpers = ['QuizRow', 'QuizQuestionRow', 'AssignmentRow'];
  for (const helper of expectedHelpers) {
    if (!content.includes(`export type ${helper}`)) {
      issues.push({
        type: 'warning',
        message: `generated.ts missing "${helper}" helper type export`,
      });
    }
  }

  // Check for signs of manual editing in the Database type body
  // The auto-generated types should not have inline comments explaining business logic
  const databaseTypeMatch = content.match(/export type Database = \{[\s\S]*?\n\};/);
  if (databaseTypeMatch) {
    const databaseTypeBody = databaseTypeMatch[0];
    // Check for suspicious inline comments that suggest manual editing
    // (auto-generated types typically only have // UUID or similar simple annotations)
    const suspiciousPatterns = [
      /\/\/\s*TODO/i,
      /\/\/\s*FIXME/i,
      /\/\/\s*NOTE:/i,
      /\/\/\s*HACK/i,
      /\/\*[\s\S]*?This was manually/i,
    ];

    for (const pattern of suspiciousPatterns) {
      if (pattern.test(databaseTypeBody)) {
        issues.push({
          type: 'warning',
          message: 'generated.ts Database type contains comments suggesting manual editing - please regenerate',
        });
        break;
      }
    }
  }

  return { exists: true, issues };
}

function checkTypeFile(filePath, _schemaTypes) {
  if (!fs.existsSync(filePath)) {
    return { exists: false, issues: [] };
  }

  const content = fs.readFileSync(filePath, 'utf-8');
  const issues = [];

  // Check for UUID fields that might be typed as number (in request types, not DB types)
  // Only check in API Request sections, not in types that extend generated types
  const requestTypesSection = content.match(/API REQUEST TYPES[\s\S]*?(?=\/\/\s*===|$)/);
  if (requestTypesSection) {
    const requestContent = requestTypesSection[0];
    // Check for numeric IDs in request types (quizId, questionId should be string)
    if (/quizId\s*:\s*number/.test(requestContent)) {
      issues.push({
        type: 'error',
        message: 'Request type has "quizId: number" - should be "string" (UUID)',
      });
    }
    if (/questionId\s*:\s*number/.test(requestContent)) {
      issues.push({
        type: 'error',
        message: 'Request type has "questionId: number" - should be "string" (UUID)',
      });
    }
  }

  // Check for known schema mismatches
  if (content.includes('time_limit:') && !content.includes('time_limit_minutes:')) {
    issues.push({
      type: 'error',
      message: 'Quiz field should be "time_limit_minutes" not "time_limit"',
    });
  }

  // Check that types import from generated.ts
  const basename = path.basename(filePath);
  if (['quiz.ts', 'assignment.ts', 'index.ts'].includes(basename)) {
    if (!content.includes("from './generated'")) {
      issues.push({
        type: 'warning',
        message: `${basename} should import from './generated' to stay in sync with schema`,
      });
    }
  }

  return { exists: true, issues };
}

/**
 * Run the field name scanner as a child process
 * Returns the exit code from the scanner
 */
function runFieldNameScanner() {
  return new Promise((resolve) => {
    console.log('\n--- Field Name Usage Check ---');
    console.log('Scanning codebase for field name references...\n');

    const scannerPath = path.join(__dirname, 'scan-field-names.js');

    // Check if scanner exists
    if (!fs.existsSync(scannerPath)) {
      console.log('[SKIP] Field name scanner not found');
      console.log('  Create scripts/scan-field-names.js to enable this check');
      resolve(0);
      return;
    }

    const child = spawn('node', [scannerPath], {
      stdio: 'inherit',
      cwd: path.join(__dirname, '..'),
    });

    child.on('close', (code) => {
      resolve(code || 0);
    });

    child.on('error', (err) => {
      console.log(`[ERROR] Failed to run field name scanner: ${err.message}`);
      resolve(1);
    });
  });
}

async function main() {
  console.log('Schema-Types Synchronization Check\n');
  console.log('='.repeat(50));

  // Parse schema.sql
  let schemaContent;
  try {
    schemaContent = fs.readFileSync(SCHEMA_PATH, 'utf-8');
  } catch (err) {
    console.error(`Error reading schema.sql: ${err.message}`);
    process.exit(1);
  }

  const schemaTypes = parseSchemaSQL(schemaContent);
  console.log(`\nParsed ${Object.keys(schemaTypes).length} LMS tables from schema.sql`);

  let totalIssues = 0;

  // Check generated.ts first
  console.log('\n--- Generated Types Check ---');
  const generatedResult = checkGeneratedTypes();
  if (!generatedResult.exists) {
    console.log('\n[ERROR] generated.ts - file not found');
    for (const issue of generatedResult.issues) {
      console.log(`  ERROR: ${issue.message}`);
      if (issue.type === 'error') totalIssues++;
    }
  } else if (generatedResult.issues.length === 0) {
    console.log('\n[OK] generated.ts - structure valid');
  } else {
    console.log('\n[ISSUES] generated.ts:');
    for (const issue of generatedResult.issues) {
      const prefix = issue.type === 'error' ? '  ERROR:' : '  WARN:';
      console.log(`${prefix} ${issue.message}`);
      if (issue.type === 'error') totalIssues++;
    }
  }

  // Check type files
  console.log('\n--- Manual Type Files Check ---');
  const typeFiles = ['index.ts', 'quiz.ts', 'assignment.ts'];

  for (const file of typeFiles) {
    const filePath = path.join(TYPES_DIR, file);
    const result = checkTypeFile(filePath, schemaTypes);

    if (!result.exists) {
      console.log(`\n[SKIP] ${file} - file not found`);
      continue;
    }

    if (result.issues.length === 0) {
      console.log(`\n[OK] ${file} - no issues found`);
    } else {
      console.log(`\n[ISSUES] ${file}:`);
      for (const issue of result.issues) {
        const prefix = issue.type === 'error' ? '  ERROR:' : '  WARN:';
        console.log(`${prefix} ${issue.message}`);
        if (issue.type === 'error') totalIssues++;
      }
    }
  }

  // Run field name scanner if requested
  let fieldScanIssues = 0;
  if (WITH_FIELD_SCAN) {
    fieldScanIssues = await runFieldNameScanner();
    if (fieldScanIssues > 0) {
      totalIssues += fieldScanIssues;
    }
  }

  // Summary
  console.log('\n' + '='.repeat(50));
  if (totalIssues > 0) {
    console.log(`\nFailed: ${totalIssues} error(s) found`);
    console.log('\nTo fix schema-type mismatches:');
    console.log('1. Run "npm run db:types" to regenerate types from schema');
    console.log('2. Update manual type definitions to match schema.sql');
    console.log('3. Ensure all UUID columns use "string" type');
    console.log('4. Ensure types extend/compose generated types where appropriate');
    if (fieldScanIssues > 0) {
      console.log('5. Fix field name mismatches (use snake_case for database fields)');
    }
    process.exit(1);
  } else {
    console.log('\nPassed: No critical issues found');
    console.log('\nNote: Types are using generated.ts as the source of truth.');
    console.log('After schema changes, regenerate types with: npm run db:types');
    if (!WITH_FIELD_SCAN) {
      console.log('\nTip: Run with --with-field-scan to check field names in code');
    }
    process.exit(0);
  }
}

main();
