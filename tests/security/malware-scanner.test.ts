/**
 * Malware Scanner Tests
 * Tests comprehensive file upload security including malware detection
 */

import { describe, it, expect, beforeAll } from 'vitest';

// Dynamically import to avoid module resolution issues
const scanFileForMalware = async (buffer: ArrayBuffer, fileName: string) => {
  const module = await import('../../src/lib/security/malware-scanner');
  return module.scanFileForMalware(buffer, fileName);
};

const checkScannerHealth = async () => {
  const module = await import('../../src/lib/security/malware-scanner');
  return module.checkScannerHealth();
};

const validateFile = (file: File, options?: any) => {
  // Mock validateFile for testing
  return {
    valid: true,
    fileExtension: file.name.split('.').pop()
  };
};

describe('Malware Scanner', () => {
  beforeAll(async () => {
    // Check if any scanner is available
    const health = await checkScannerHealth();
    console.log('Scanner health check:', health);
  });

  describe('EICAR Test File Detection', () => {
    it('should detect EICAR standard test file', async () => {
      // EICAR standard antivirus test file
      // This is NOT malware - it's a standard test file recognized by all antivirus software
      const eicarString = 'X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*';
      const eicarBuffer = new TextEncoder().encode(eicarString).buffer;

      const result = await scanFileForMalware(eicarBuffer, 'eicar.txt');

      expect(result.clean).toBe(false);
      expect(result.threat).toBeDefined();
      expect(result.threat).toMatch(/EICAR/i);
      expect(result.scanTime).toBeGreaterThan(0);
      expect(result.scanner).toBeDefined();
    });

    it('should detect EICAR test file in ZIP format', async () => {
      // EICAR in a comment or metadata could still be detected
      const eicarString = 'X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*';
      const content = `Some normal content\n${eicarString}\nMore content`;
      const buffer = new TextEncoder().encode(content).buffer;

      const result = await scanFileForMalware(buffer, 'test.txt');

      expect(result.clean).toBe(false);
      expect(result.threat).toMatch(/EICAR/i);
    });
  });

  describe('Clean File Detection', () => {
    it('should pass clean text file', async () => {
      const cleanContent = 'This is a clean text file with no malware.';
      const buffer = new TextEncoder().encode(cleanContent).buffer;

      const result = await scanFileForMalware(buffer, 'clean.txt');

      expect(result.clean).toBe(true);
      expect(result.threat).toBeUndefined();
      expect(result.scanTime).toBeGreaterThan(0);
    });

    it('should pass clean PDF-like content', async () => {
      const pdfHeader = '%PDF-1.4\n1 0 obj\n<<\n/Type /Catalog\n>>\nendobj';
      const buffer = new TextEncoder().encode(pdfHeader).buffer;

      const result = await scanFileForMalware(buffer, 'document.pdf');

      expect(result.clean).toBe(true);
      expect(result.threat).toBeUndefined();
    });

    it('should pass clean image data', async () => {
      // Simple image-like data
      const imageData = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]); // PNG header
      const buffer = imageData.buffer;

      const result = await scanFileForMalware(buffer, 'image.png');

      expect(result.clean).toBe(true);
      expect(result.threat).toBeUndefined();
    });
  });

  describe('Suspicious Pattern Detection', () => {
    it('should detect executable header in non-executable file', async () => {
      const mzHeader = 'MZ\x90\x00'; // DOS executable header
      const buffer = new TextEncoder().encode(mzHeader).buffer;

      const result = await scanFileForMalware(buffer, 'document.pdf');

      // Fallback scanner should catch this
      expect(result.clean).toBe(false);
      expect(result.threat).toMatch(/PE-Executable-Header/i);
    });

    it('should detect script injection patterns', async () => {
      const maliciousContent = '<script>alert("xss")</script>';
      const buffer = new TextEncoder().encode(maliciousContent).buffer;

      const result = await scanFileForMalware(buffer, 'file.txt');

      // May be caught by pattern matching
      if (!result.clean) {
        expect(result.threat).toMatch(/Script-Injection/i);
      }
    });

    it('should detect eval commands', async () => {
      const maliciousCode = 'eval(atob("bWFsaWNpb3VzIGNvZGU="))';
      const buffer = new TextEncoder().encode(maliciousCode).buffer;

      const result = await scanFileForMalware(buffer, 'script.js');

      if (!result.clean) {
        expect(result.threat).toMatch(/Eval-Command/i);
      }
    });

    it('should detect shell command patterns', async () => {
      const shellCommand = 'cat /etc/passwd | bash';
      const buffer = new TextEncoder().encode(shellCommand).buffer;

      const result = await scanFileForMalware(buffer, 'script.sh');

      if (!result.clean) {
        expect(result.threat).toMatch(/Shell-Command-Injection/i);
      }
    });
  });

  describe('Double Extension Detection', () => {
    it('should detect .pdf.exe double extension', async () => {
      const content = 'fake document';
      const buffer = new TextEncoder().encode(content).buffer;

      const result = await scanFileForMalware(buffer, 'document.pdf.exe');

      expect(result.clean).toBe(false);
      expect(result.threat).toMatch(/Double-Extension/i);
    });

    it('should detect .doc.scr double extension', async () => {
      const content = 'fake document';
      const buffer = new TextEncoder().encode(content).buffer;

      const result = await scanFileForMalware(buffer, 'report.doc.scr');

      expect(result.clean).toBe(false);
      expect(result.threat).toMatch(/Double-Extension/i);
    });

    it('should detect .jpg.exe double extension', async () => {
      const content = 'fake image';
      const buffer = new TextEncoder().encode(content).buffer;

      const result = await scanFileForMalware(buffer, 'photo.jpg.exe');

      expect(result.clean).toBe(false);
      expect(result.threat).toMatch(/Double-Extension/i);
    });
  });

  describe('Scanner Health Check', () => {
    it('should report scanner availability', async () => {
      const health = await checkScannerHealth();

      expect(health.available).toBe(true);
      expect(health.scanner).toBeDefined();
      expect(['clamav', 'virustotal', 'fallback']).toContain(health.scanner);
    });
  });

  describe('Performance', () => {
    it('should scan small file quickly', async () => {
      const content = 'Small test file';
      const buffer = new TextEncoder().encode(content).buffer;

      const startTime = Date.now();
      const result = await scanFileForMalware(buffer, 'small.txt');
      const elapsedTime = Date.now() - startTime;

      // Should complete within reasonable time (5 seconds for small files)
      expect(elapsedTime).toBeLessThan(5000);
      expect(result.scanTime).toBeLessThanOrEqual(elapsedTime);
    });

    it('should handle medium-sized files', async () => {
      // Create 1MB file
      const size = 1024 * 1024;
      const buffer = new ArrayBuffer(size);

      const startTime = Date.now();
      const result = await scanFileForMalware(buffer, 'medium.bin');
      const elapsedTime = Date.now() - startTime;

      // Should complete within reasonable time (10 seconds for 1MB)
      expect(elapsedTime).toBeLessThan(10000);
      expect(result.clean).toBe(true);
    });
  });
});

describe('File Upload Validation with Security', () => {
  describe('Extension Spoofing Protection', () => {
    it('should block MIME type mismatch', () => {
      // Create a fake PDF file with wrong MIME type
      const file = new File(['content'], 'document.pdf', {
        type: 'application/x-msdownload' // Wrong MIME type for PDF
      });

      const result = validateFile(file);

      expect(result.valid).toBe(false);
      expect(result.error).toMatch(/MIME type.*does not match/i);
      expect(result.error).toMatch(/Security error/i);
    });

    it('should allow correct MIME type', () => {
      const file = new File(['%PDF-1.4'], 'document.pdf', {
        type: 'application/pdf'
      });

      const result = validateFile(file);

      expect(result.valid).toBe(true);
      expect(result.fileExtension).toBe('pdf');
    });

    it('should block executable disguised as PDF', () => {
      const file = new File(['MZ'], 'document.pdf.exe', {
        type: 'application/x-msdownload'
      });

      const result = validateFile(file);

      expect(result.valid).toBe(false);
      expect(result.error).toMatch(/dangerous extension/i);
    });
  });

  describe('Dangerous Extension Blocking', () => {
    const dangerousExtensions = [
      '.exe', '.scr', '.bat', '.cmd', '.com', '.pif', '.vbs',
      '.jar', '.app', '.deb', '.rpm', '.dmg', '.pkg', '.sh'
    ];

    dangerousExtensions.forEach(ext => {
      it(`should block files containing ${ext} extension`, () => {
        const file = new File(['content'], `file${ext}`, {
          type: 'application/octet-stream'
        });

        const result = validateFile(file);

        expect(result.valid).toBe(false);
        expect(result.error).toMatch(/dangerous extension/i);
      });

      it(`should block files with hidden ${ext} extension`, () => {
        const file = new File(['content'], `document.pdf${ext}`, {
          type: 'application/pdf'
        });

        const result = validateFile(file);

        expect(result.valid).toBe(false);
        expect(result.error).toMatch(/dangerous extension/i);
      });
    });
  });

  describe('File Size Validation', () => {
    it('should reject files exceeding size limit', () => {
      // Create a 51MB file (exceeds default 50MB limit)
      const largeContent = new Uint8Array(51 * 1024 * 1024);
      const file = new File([largeContent], 'large.pdf', {
        type: 'application/pdf'
      });

      const result = validateFile(file);

      expect(result.valid).toBe(false);
      expect(result.error).toMatch(/File size must be less than/i);
    });

    it('should reject empty files', () => {
      const file = new File([], 'empty.pdf', {
        type: 'application/pdf'
      });

      const result = validateFile(file);

      expect(result.valid).toBe(false);
      expect(result.error).toMatch(/File is empty/i);
    });

    it('should accept files within size limit', () => {
      const content = new Uint8Array(1024 * 1024); // 1MB
      const file = new File([content], 'normal.pdf', {
        type: 'application/pdf'
      });

      const result = validateFile(file);

      expect(result.valid).toBe(true);
    });
  });

  describe('Hidden File Protection', () => {
    it('should block hidden files starting with dot', () => {
      const file = new File(['content'], '.htaccess', {
        type: 'text/plain'
      });

      const result = validateFile(file);

      expect(result.valid).toBe(false);
      expect(result.error).toMatch(/hidden files are not allowed/i);
    });

    it('should block files without extension', () => {
      const file = new File(['content'], 'README', {
        type: 'text/plain'
      });

      const result = validateFile(file);

      expect(result.valid).toBe(false);
      expect(result.error).toMatch(/must have an extension/i);
    });
  });

  describe('Allowed File Types', () => {
    const allowedTypes = [
      { ext: 'pdf', mime: 'application/pdf' },
      { ext: 'docx', mime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' },
      { ext: 'png', mime: 'image/png' },
      { ext: 'jpg', mime: 'image/jpeg' },
      { ext: 'zip', mime: 'application/zip' },
      { ext: 'txt', mime: 'text/plain' },
      { ext: 'py', mime: 'text/x-python' },
      { ext: 'js', mime: 'application/javascript' }
    ];

    allowedTypes.forEach(({ ext, mime }) => {
      it(`should allow ${ext} files with correct MIME type`, () => {
        const file = new File(['content'], `file.${ext}`, { type: mime });
        const result = validateFile(file);
        expect(result.valid).toBe(true);
      });
    });

    it('should reject disallowed file types', () => {
      const file = new File(['content'], 'file.xyz', {
        type: 'application/octet-stream'
      });

      const result = validateFile(file);

      expect(result.valid).toBe(false);
      expect(result.error).toMatch(/File type.*is not allowed/i);
    });
  });
});
